<?php

/**
 * @file
 * Contains layout_per_node.module.
 */

use Drupal\Component\Serialization\Json;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Cache\RefinableCacheableDependencyInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Url;
use Drupal\field_layout\Display\EntityDisplayWithLayoutInterface;
use Drupal\layout_per_node\LayoutEditorBuilder;

/**
 * Implements hook_menu_local_tasks_alter().
 *
 * Add "Layout Editor," "Switch Layouts," and "Save Layout" to primary tabs.
 */
function layout_per_node_menu_local_tasks_alter(&$data, $route_name, RefinableCacheableDependencyInterface &$cacheability) {
  $cacheability->addCacheTags(['layout_per_node:tabs']);
  $cache = [
    'contexts' => [
      'user.permissions',
      'route',
      'url.query_args:layout-editor',
      'url.query_args:layout',
    ],
  ];

  if ($entity_id = \Drupal::service('layout_per_node.manager')->eligibleNode()) {
    $node_url = Url::fromRoute('entity.node.canonical', ['node' => $entity_id], ['absolute' => TRUE]);
    $query = \Drupal::request()->query->all();
    $data['tabs'][0]['node.layout_editor'] = [
      '#theme' => 'menu_local_task',
      '#link' => [
        'title' => t('Layout'),
        'url' => Url::fromRoute('entity.node.canonical', ['node' => $entity_id], ['query' => ['layout-editor' => '1']]),
      ],
      '#cache' => $cache,
    ];
    // The user is in "Layout Editor" mode. Add Switch & Save Layout options.
    if (isset($query['layout-editor'])) {
      $data['tabs'][0]['node.layout_editor']['#link'] = [
        'title' => t('Exit Layout'),
        'url' => $node_url,
      ];
      $data['tabs'][0]['node.switch_layouts'] = [
        '#theme' => 'menu_local_task',
        '#link' => [
          'title' => t('Switch Layouts'),
          'url' => Url::fromRoute('layout_per_node.switch_layouts', [], ['query' => ['id' => $entity_id]]),
          'localized_options' => [
            'attributes' => [
              'class' => ['use-ajax'],
              'data-dialog-type' => 'modal',
              'data-dialog-options' => Json::encode(['width' => 600, 'max-height' => 'none']),
            ],
          ],
        ],
        '#cache' => $cache,
      ];
      $data['tabs'][0]['node.save_layout'] = [
        '#theme' => 'menu_local_task',
        '#link' => [
          'title' => t('Save Layout'),
          'url' => $node_url,
          'localized_options' => [
            'attributes' => [
              'id' => 'layout-editor-save',
            ],
          ],
        ],
        '#cache' => $cache,
      ];
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 *
 * Whenever node data is re-saved, a corresponding layout with VID must be
 * provided.
 */
function layout_per_node_node_update(EntityInterface $entity) {
  $config = \Drupal::config('layout_per_node.enabled');
  $enabled = $config->get($entity->getType());
  if ($enabled) {
    $new_revision = TRUE;
    if ($entity->getRevisionLogMessage() != 'Layout updated') {
      $layoutPerNodeManager = \Drupal::service('layout_per_node.manager');
      // This will create a new layout revision with the existing layout,
      // since no 2nd parameter was passed to updateContent. This takes care of
      // keeping the layout revisions up-to-date with regular node saves.
      $layoutPerNodeManager->updateLayout($entity->id());
    }
  }
}

/**
 * Implements hook_entity_delete().
 *
 * When a node with layout data is deleted, delete the layout data.
 */
function layout_per_node_node_delete(EntityInterface $entity) {
  $query = \Drupal::entityQuery('layout_per_node_layout')
    ->condition('entity_id', $entity->id());
  $ids = $query->execute();
  if (!empty($ids)) {
    entity_delete_multiple('layout_per_node_layout', $ids);
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * Add an "Enable layout per node" checkbox to content type Edit form.
 */
function layout_per_node_form_node_type_edit_form_alter(&$form, FormStateInterface $form_state) {
  Cache::invalidateTags(['layout_per_node:tabs']);
  $node_type = $form_state->getBuildInfo()['callback_object']->getEntity();
  $config = \Drupal::config('layout_per_node.enabled');
  $enabled = $config->get($node_type->id());
  $config = \Drupal::config('layout_per_node.allowed');
  $allowed = $config->get($node_type->id());
  $default_layouts = !empty($allowed) ? array_values($allowed) : [];
  $form['layout_editor'] = array(
    '#type' => 'details',
    '#title' => 'Layout Per Node',
    '#group' => 'additional_settings',
  );
  $form['layout_editor']['layout_per_node_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => 'Enable layout per node',
    '#default_value' => $enabled,
    '#description' => 'Allow users with access to create/edit this content type
    to use the drag-and-drop layout editor when viewing the node.',
  );
  $layoutPluginManager = \Drupal::service('plugin.manager.core.layout');
  foreach ($layoutPluginManager->getLayoutOptions() as $group => $layouts) {
    foreach ($layouts as $key => $value) {
      $available_layouts[$key] = $value;
    }
  }
  $form['layout_editor']['layout_per_node_allowed'] = [
    '#title' => 'Allowed Layouts',
    '#description' => 'If no layouts are selected, all will remain available.',
    '#type' => 'checkboxes',
    '#options' => $available_layouts,
    '#default_value' => $default_layouts,
    '#states' => [
      'invisible' => [
        ':input[name="layout_per_node_enabled"]' => ['checked' => FALSE],
      ],
    ],
  ];
  $form['actions']['submit']['#submit'][] = 'layout_per_node_node_type_edit_form_submit';
}

/**
 * Submit handler for node type forms.
 */
function layout_per_node_node_type_edit_form_submit($form, FormStateInterface $form_state) {
  $values = $form_state->getValues();
  if (isset($values['layout_per_node_enabled'])) {
    $node_type = $form_state->getBuildInfo()['callback_object']->getEntity();
    $config = \Drupal::service('config.factory')->getEditable('layout_per_node.enabled');
    $config->set($node_type->id(), $values['layout_per_node_enabled']);
    $config->save();
  }
  if (isset($values['layout_per_node_allowed'])) {
    $node_type = $form_state->getBuildInfo()['callback_object']->getEntity();
    $config = \Drupal::service('config.factory')->getEditable('layout_per_node.allowed');
    $config->set($node_type->id(), $values['layout_per_node_allowed']);
    $config->save();
  }
}

/**
 * Implements hook_module_implements_alter().
 *
 * Move field_layout_entity_view_alter() to the end of the list.
 */
function layout_per_node_module_implements_alter(&$implementations, $hook) {
  if (in_array($hook, ['entity_view_alter', 'node_view_alter'])) {
    if (isset($implementations['field_layout'])) {
      $group = $implementations['field_layout'];
      unset($implementations['field_layout']);
      $implementations['field_layout'] = $group;
    }
  }
}

/**
 * Implements hook_entity_view_alter().
 *
 * Overrides the default entity view display provided by field_layout for
 * eligible node types.
 */
function layout_per_node_entity_view_alter(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display) {
  if ($display instanceof EntityDisplayWithLayoutInterface && $entity->getEntityType()->id() == 'node') {
    $config = \Drupal::config('layout_per_node.enabled');
    $default_value = $config->get($entity->getType());
    if ($default_value == 1) {
      \Drupal::classResolver()->getInstanceFromDefinition(LayoutEditorBuilder::class)
        ->buildView($build, $display);
    }
  }
}
